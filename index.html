<!--
README
- Esegui in locale aprendo index.html in un browser moderno con config.js nella stessa cartella.
- Pubblica su GitHub Pages effettuando il commit di index.html, config.js e links.html, facendo push sul branch principale e attivando GitHub Pages per quel branch o per la cartella /docs.
- Configura videos, SURVEY_TITLE e FORM_ENDPOINT in config.js; aggiorna i valori in base al tuo progetto prima di condividere il questionario.
- La coda offline salva le risposte non inviate per ogni sessione del partecipante in localStorage, ritenta automaticamente a ogni navigazione, quando la connessione torna attiva, e usa navigator.sendBeacon alla chiusura della scheda.
- Condividi direttamente index.html con i partecipanti; non è richiesto alcun codice di accesso o parametro uid.

Promemoria per la configurazione di Formspree
- Crea un form su https://formspree.io e copia l'endpoint simile a https://formspree.io/f/XXXXYYYY.
- Incolla quell'URL in CONFIG.FORM_ENDPOINT dentro config.js. Formspree accetta JSON quando l'header Accept è impostato su application/json.
- Aggiungi dal pannello di Formspree le regole di notifica di cui hai bisogno.
-->
<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Questionario</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geologica:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Geologica', 'Inter', 'Segoe UI', system-ui, sans-serif;
      font-size: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #17202a 0%, #0b1118 55%, #05070a 100%);
      color: #f5f7fa;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: clamp(2rem, 4vw, 3.5rem) clamp(1rem, 3vw, 2.25rem) clamp(3rem, 6vw, 4.75rem);
    }

    #app {
      width: 100%;
      max-width: 1240px;
      margin: 0 auto;
    }

    .card {
      background: rgba(18, 24, 32, 0.9);
      backdrop-filter: blur(8px);
      border-radius: 16px;
      padding: clamp(2.5rem, 2.5vw + 2rem, 3.25rem);
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(90, 120, 150, 0.25);
    }

    h1, h2, h3 {
      margin: 0;
      line-height: 1.2;
      letter-spacing: 0.02em;
    }

    h1 {
      font-size: clamp(1.8rem, 2.2vw + 1rem, 2.6rem);
      font-weight: 600;
    }

    h2 {
      font-size: 1.35rem;
      margin-bottom: 1rem;
    }

    p {
      margin: 0 0 1rem;
      line-height: 1.6;
      color: #d9e2ef;
    }

    .welcome {
      text-align: center;
      max-width: 860px;
      margin: 0 auto;
    }

    .welcome h1 {
      margin-bottom: 1.75rem;
    }

    .welcome p {
      margin: 0 auto 1.5rem;
      font-size: 1.05rem;
      line-height: 1.75;
      max-width: 640px;
    }

    .welcome button {
      margin-top: 1.5rem;
    }

    .logo {
      width: min(220px, 60vw);
      margin: 0 auto 2rem;
      padding: 1rem;
      background: rgba(12, 18, 26, 0.85);
      border-radius: 28px;
      border: 1px solid rgba(132, 153, 188, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
    }

    .logo img {
      width: 100%;
      height: auto;
      display: block;
    }

    button {
      font: inherit;
      border-radius: 999px;
      padding: 0.85rem 1.8rem;
      border: 1px solid rgba(110, 150, 255, 0.35);
      color: #0b1118;
      background: linear-gradient(135deg, #6cb5ff, #75ffe5);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.04em;
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.2s ease;
      min-width: 140px;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(71, 194, 255, 0.35);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      box-shadow: none;
      transform: none;
    }

    button:focus-visible {
      outline: 3px solid rgba(108, 181, 255, 0.9);
      outline-offset: 2px;
    }

    .secondary {
      background: transparent;
      color: #e2e9f2;
      border: 1px solid rgba(132, 153, 188, 0.7);
    }

    .secondary:hover {
      box-shadow: 0 10px 24px rgba(132, 153, 188, 0.25);
    }

    .primary {
      margin-left: auto;
    }

    .video-step {
      display: flex;
      gap: clamp(1.5rem, 3vw, 3rem);
      align-items: stretch;
      margin-top: 2.5rem;
      flex-wrap: wrap;
    }

    .video-area {
      flex: 1 1 480px;
      min-width: 300px;
    }

    .video-area.has-fallback video {
      display: none;
    }

    video {
      width: 100%;
      border-radius: 18px;
      border: 1px solid rgba(104, 140, 201, 0.35);
      background: #04070d;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
    }

    .video-fallback {
      margin-top: 1rem;
      padding: 1rem 1.25rem;
      border-radius: 12px;
      border: 1px solid rgba(132, 153, 188, 0.35);
      background: rgba(12, 18, 26, 0.85);
      color: #dbe5f3;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .video-area.has-fallback .video-fallback {
      margin-top: 0;
    }

    .video-fallback p {
      margin: 0 0 0.75rem;
    }

    .video-fallback__player {
      margin-top: 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(132, 153, 188, 0.35);
      background: #04070d;
      overflow: hidden;
      aspect-ratio: 16 / 9;
      min-height: 240px;
    }

    .video-fallback__player iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      background: #000;
    }

    .video-fallback a {
      color: #6cb5ff;
      font-weight: 600;
      text-decoration: none;
    }

    .video-fallback a:hover,
    .video-fallback a:focus-visible {
      text-decoration: underline;
      outline: none;
    }

    .questions {
      flex: 1 1 360px;
      min-width: 300px;
      background: rgba(12, 17, 25, 0.85);
      border-radius: 18px;
      padding: 2rem;
      border: 1px solid rgba(90, 120, 150, 0.2);
    }

    fieldset {
      border: none;
      padding: 0;
      margin: 0 0 1.75rem;
    }

    legend {
      font-size: 1.15rem;
      margin-bottom: 1rem;
      font-weight: 600;
      color: #f2f5ff;
    }

    .option {
      display: block;
      margin-bottom: 0.85rem;
      font-size: 1.08rem;
      color: #dbe5f3;
    }

    .option input[type="radio"] {
      margin-right: 0.65rem;
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #6cb5ff;
    }

    .stars-fieldset {
      margin-bottom: 0.5rem;
    }

    .stars {
      display: inline-flex;
      gap: 0.35rem;
      align-items: center;
    }

    .stars input[type="radio"] {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .stars label {
      font-size: 2.2rem;
      color: #2f3845;
      cursor: pointer;
      transition: color 0.2s ease, transform 0.2s ease;
      padding: 0.1rem 0.25rem;
      border-radius: 0.4rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 2.2rem;
    }

    .stars label.active {
      color: #f6c445;
    }

    .stars label:hover,
    .stars label:focus-visible,
    .stars input[type="radio"]:focus + label {
      color: #ffe27a;
      box-shadow: 0 0 0 2px rgba(116, 154, 255, 0.35);
    }

    .progress {
      margin-top: 0.5rem;
      font-size: 1rem;
      color: #9fb4d4;
    }

    .nav-buttons {
      display: flex;
      gap: 1.25rem;
      margin-top: 3.5rem;
    }

    .status {
      margin-top: 1.5rem;
      min-height: 1.25rem;
      font-size: 0.95rem;
      color: #a9bdd6;
    }

    .status[data-type="error"] {
      color: #ff9b9b;
    }

    .status[data-type="success"] {
      color: #7be0a0;
    }

    .status[data-type="warning"] {
      color: #ffcc80;
    }

    .status.hidden {
      visibility: hidden;
    }

    .top-bar {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .top-bar strong {
      font-weight: 600;
      color: #c0d3f2;
    }

    .final-view {
      text-align: center;
    }

    .final-message {
      margin: 1.5rem auto 0;
      font-size: 1.2rem;
      color: #dce7ff;
    }

    .final-note {
      margin: 1.75rem auto 0;
      max-width: 520px;
      font-size: 1.05rem;
      color: #c0d3f2;
      line-height: 1.6;
    }

    .final-actions {
      margin-top: 2.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .final-actions .primary {
      margin-left: 0;
    }

    .final-view .status {
      margin-top: 2.5rem;
      text-align: center;
    }

    .final-success {
      margin-top: 2.5rem;
      font-size: 1.08rem;
      color: #7be0a0;
      line-height: 1.6;
    }

    .error-view {
      text-align: center;
      max-width: 560px;
      margin: 0 auto;
    }

    .error-view h2 {
      margin-bottom: 1rem;
    }

    .debug-panel {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      background: rgba(10, 15, 22, 0.92);
      border: 1px solid rgba(120, 150, 200, 0.35);
      border-radius: 12px;
      padding: 1rem 1.25rem;
      font-size: 0.9rem;
      color: #c8d9f1;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      max-width: 260px;
      z-index: 50;
    }

    .debug-panel h3 {
      font-size: 1rem;
      margin-bottom: 0.6rem;
    }

    .debug-panel button {
      margin-top: 0.8rem;
      width: 100%;
      background: rgba(120, 150, 200, 0.2);
      color: #f5f7fa;
      border-color: rgba(120, 150, 200, 0.65);
    }

    .debug-panel button:hover {
      box-shadow: none;
      transform: none;
      background: rgba(120, 150, 200, 0.35);
    }

    @media (max-width: 900px) {
      body {
        padding: 1.75rem 0.75rem 2.75rem;
      }

      .card {
        padding: 2.25rem 1.75rem;
      }

      .video-step {
        flex-direction: column;
        gap: 1.75rem;
      }

      .video-area,
      .questions {
        min-width: 0;
      }

      .questions {
        padding: 1.75rem;
      }

      .nav-buttons {
        flex-direction: column-reverse;
        align-items: stretch;
        margin-top: 2.5rem;
      }

      .primary {
        margin-left: 0;
      }
    }

    @media (max-width: 600px) {
      body {
        padding: 1.25rem 0.75rem 2rem;
      }

      .card {
        padding: 1.65rem 1.25rem;
        border-radius: 14px;
      }

      .logo {
        margin-bottom: 1.5rem;
        padding: 0.75rem;
        border-radius: 22px;
      }

      .welcome h1 {
        margin-bottom: 1.25rem;
      }

      .welcome p {
        font-size: 1rem;
        line-height: 1.6;
        margin-bottom: 1.25rem;
      }

      .video-step {
        margin-top: 1.75rem;
        gap: 1.15rem;
      }

      video {
        border-radius: 14px;
      }

      .questions {
        padding: 1.35rem;
        border-radius: 14px;
      }

      fieldset {
        margin-bottom: 1.35rem;
      }

      .option {
        margin-bottom: 0.7rem;
        font-size: 1rem;
      }

      .nav-buttons {
        margin-top: 1.75rem;
        gap: 0.85rem;
      }

      .status {
        margin-top: 1rem;
      }
    }
  </style>
  <script src="config.js"></script>
</head>
<body>
  <div id="app" role="main" aria-live="polite"></div>
  <script>
    (function () {
      'use strict';

      const appEl = document.getElementById('app');
      const state = {
        config: null,
        uid: null,
        started: false,
        currentIndex: 0,
        answers: [],
        submitted: false,
        error: null,
        statusMessage: '',
        statusType: 'info',
        debug: false,
        queueLength: 0
      };

      const storageKeys = {
        state: (uid) => `survey_state_${toStorageKeyFragment(uid)}`,
        queue: (uid) => `survey_queue_${toStorageKeyFragment(uid)}`
      };

      const SESSION_ID_STORAGE_KEY = 'survey_session_id';

      let dataAdapter = null;

      init();

      function init() {
        try {
          state.config = loadConfig();
        } catch (err) {
          state.error = err instanceof Error ? err.message : String(err);
          render();
          return;
        }

        const params = new URLSearchParams(window.location.search);
        state.debug = params.get('debug') === '1';
        state.uid = initializeSessionId(params);

        document.title = state.config.SURVEY_TITLE;

        loadStoredState();
        initRouter();
        initializeDataAdapter();

        window.addEventListener('online', () => {
          setStatus('Connessione ripristinata. Sincronizzo le risposte in sospeso…', 'info');
          flushQueue();
        });
        window.addEventListener('offline', () => {
          setStatus('Sembra che tu sia offline. Le risposte verranno sincronizzate quando ti ricollegherai.', 'warning');
        });

        window.addEventListener('pagehide', () => {
          if (dataAdapter) {
            dataAdapter.flushQueueWithBeacon();
          }
        });
        window.addEventListener('beforeunload', () => {
          if (dataAdapter) {
            dataAdapter.flushQueueWithBeacon();
          }
        });

        render();
        flushQueue();
      }

      function loadConfig() {
        const conf = window.CONFIG;
        if (!conf || typeof conf !== 'object') {
          throw new Error('Configurazione mancante. Aggiungi config.js con un oggetto CONFIG.');
        }
        const { videos, FORM_ENDPOINT, SURVEY_TITLE, VIDEO_BASE_URL } = conf;
        if (!Array.isArray(videos) || videos.length !== 10) {
          throw new Error('CONFIG.videos deve essere un array con 10 elementi.');
        }
        const normalizedVideos = normalizeVideos(videos, VIDEO_BASE_URL);
        if (!normalizedVideos.every((value) => isNonEmptyString(value))) {
          throw new Error('CONFIG.videos deve contenere URL validi o percorsi di file.');
        }
        if (typeof FORM_ENDPOINT !== 'string' || !FORM_ENDPOINT.trim()) {
          throw new Error('CONFIG.FORM_ENDPOINT è obbligatorio.');
        }
        if (typeof SURVEY_TITLE !== 'string' || !SURVEY_TITLE.trim()) {
          throw new Error('CONFIG.SURVEY_TITLE è obbligatorio.');
        }
        return {
          ...conf,
          videos: normalizedVideos
        };
      }

      function initRouter() {
        window.addEventListener('popstate', () => {
          render();
        });
        history.replaceState({ index: state.currentIndex, started: state.started }, document.title);
      }

      function initializeDataAdapter() {
        dataAdapter = createDataAdapter(state.uid);
        dataAdapter.setOnSent((record) => {
          markRecordSent(record.submission_id);
        });
        dataAdapter.setOnError((message) => {
          setStatus(message, 'error');
        });
        dataAdapter.onQueueChange((queue) => {
          handleQueueChange(queue);
        });
        state.queueLength = dataAdapter.getQueue().length;
      }

      function initializeSessionId(params) {
        const explicit = readUid(params);
        if (explicit) {
          rememberSessionId(explicit);
          return explicit;
        }
        const stored = getStoredSessionId();
        if (stored) {
          return stored;
        }
        const generated = generateSessionId();
        rememberSessionId(generated);
        return generated;
      }

      function getStoredSessionId() {
        try {
          const value = localStorage.getItem(SESSION_ID_STORAGE_KEY);
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed) {
              return trimmed;
            }
          }
        } catch (err) {
          /* ignore storage errors */
        }
        return null;
      }

      function rememberSessionId(value) {
        if (typeof value !== 'string') {
          return;
        }
        const normalized = value.trim();
        if (!normalized) {
          return;
        }
        try {
          localStorage.setItem(SESSION_ID_STORAGE_KEY, normalized);
        } catch (err) {
          /* ignore storage errors */
        }
      }

      function generateSessionId() {
        const random = Math.random().toString(16).slice(2, 10);
        const timestamp = Date.now().toString(16);
        return `anon-${timestamp}-${random}`;
      }

      function toStorageKeyFragment(uid) {
        if (typeof uid !== 'string') {
          return 'anonymous';
        }
        const trimmed = uid.trim();
        if (!trimmed) {
          return 'anonymous';
        }
        return trimmed.replace(/[^a-z0-9_-]/gi, '_');
      }

      function getStateStorage() {
        try {
          return window.sessionStorage;
        } catch (err) {
          return null;
        }
      }

      function readUid(params) {
        if (!(params instanceof URLSearchParams)) {
          params = new URLSearchParams(window.location.search);
        }
        const uid = params.get('uid');
        if (!uid) {
          return null;
        }
        const trimmed = uid.trim();
        return trimmed.length > 0 ? trimmed : null;
      }

      function loadStoredState() {
        const storage = getStateStorage();
        if (!storage) {
          return;
        }
        const raw = storage.getItem(storageKeys.state(state.uid));
        if (!raw) {
          return;
        }
        try {
          const saved = JSON.parse(raw);
          if (saved && typeof saved === 'object') {
            state.started = Boolean(saved.started);
            const maxIndex = state.config.videos.length;
            state.currentIndex = typeof saved.currentIndex === 'number' && saved.currentIndex >= 0 ? Math.min(saved.currentIndex, maxIndex) : 0;
            state.submitted = Boolean(saved.submitted);
            if (Array.isArray(saved.answers)) {
              state.answers = saved.answers.map((item) => normalizeAnswer(item));
            }
          }
        } catch (err) {
          console.warn('Impossibile caricare lo stato salvato', err);
        }
      }

      function normalizeAnswer(value) {
        if (!value || typeof value !== 'object') {
          return {};
        }
        const normalized = {
          is_ai: value.is_ai === 'yes' || value.is_ai === 'no' ? value.is_ai : undefined,
          quality: typeof value.quality === 'number' ? value.quality : undefined,
          posted: Boolean(value.posted),
          submissionId: typeof value.submissionId === 'string' ? value.submissionId : undefined
        };
        return normalized;
      }

      function persistState() {
        if (!state.uid) {
          return;
        }
        const payload = {
          started: state.started,
          currentIndex: state.currentIndex,
          answers: state.answers,
          submitted: state.submitted
        };
        const storage = getStateStorage();
        if (!storage) {
          return;
        }
        try {
          storage.setItem(storageKeys.state(state.uid), JSON.stringify(payload));
        } catch (err) {
          console.warn('Impossibile salvare lo stato', err);
        }
      }

      function getRoute() {
        if (state.error) {
          return 'error';
        }
        if (!state.started) {
          return 'welcome';
        }
        if (state.currentIndex >= state.config.videos.length) {
          return 'final';
        }
        return 'step';
      }

      function render() {
        const route = getRoute();
        if (route === 'error') {
          renderError();
        } else if (route === 'welcome') {
          renderWelcome();
        } else if (route === 'final') {
          renderFinal();
        } else {
          renderStep(state.currentIndex);
        }
        renderDebugPanel();
        renderStatus();
        history.replaceState({ index: state.currentIndex, started: state.started }, document.title);
      }

      function renderError() {
        const title = 'Errore di configurazione';
        const description = typeof state.error === 'string'
          ? state.error
          : 'Contatta l\'organizzatore per ricevere assistenza.';
        appEl.innerHTML = `
          <section class="card error-view" aria-labelledby="error-title">
            <h1 id="error-title">${escapeHtml(title)}</h1>
            <p>${escapeHtml(description)}</p>
            <p>Se il problema persiste, contatta il coordinatore dello studio.</p>
          </section>
        `;
      }

      function renderWelcome() {
        appEl.innerHTML = `
          <section class="card welcome" aria-labelledby="welcome-title">
            <div class="logo">
              <img src="MFE_-_MediaForEurope_Logo%20(1).png" alt="Logo MediaForEurope">
            </div>
            <h1 id="welcome-title">${escapeHtml(state.config.SURVEY_TITLE)}</h1>
            <p>Grazie per aiutarci a valutare i video doppiati con l\'IA. Guarderai ${state.config.videos.length} clip e risponderai a due domande rapide per ciascuna.</p>
            <p>I progressi restano salvati finch&eacute; questa scheda rimane aperta; se la chiudi, il questionario ripartir&agrave; dall\'inizio.</p>
            <button type="button" id="start-btn">Inizia</button>
            <div class="status" data-role="status" aria-live="polite"></div>
          </section>
        `;
        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', () => {
          state.started = true;
          if (state.currentIndex >= state.config.videos.length) {
            state.currentIndex = 0;
          }
          persistState();
          render();
        });
      }

      function renderStep(index) {
        const answer = state.answers[index] || {};
        const total = state.config.videos.length;
        const isAi = answer.is_ai;
        const quality = typeof answer.quality === 'number' ? answer.quality : 0;
        const videoUrl = state.config.videos[index];
        const videoMimeType = getVideoMimeType(videoUrl);
        appEl.innerHTML = `
          <section class="card" aria-labelledby="step-title">
            <header class="top-bar">
              <h1 id="step-title">${escapeHtml(state.config.SURVEY_TITLE)}</h1>
              <p class="progress">Video ${index + 1} di ${total}</p>
            </header>
            <div class="video-step">
              <div class="video-area" data-role="video-area">
                <video controls preload="metadata" src="${escapeAttribute(videoUrl)}">
                  <source src="${escapeAttribute(videoUrl)}" type="${escapeAttribute(videoMimeType)}">
                  Il tuo browser non supporta il tag video.
                </video>
                <div class="video-fallback" data-role="video-fallback" role="alert" hidden>
                  <p>Non siamo riusciti a caricare il video automaticamente. Abbiamo attivato un lettore alternativo qui sotto; se non dovesse funzionare, <a href="${escapeAttribute(videoUrl)}" target="_blank" rel="noopener noreferrer">aprilo in una nuova scheda</a>.</p>
                  <div class="video-fallback__player" data-role="video-fallback-player" hidden></div>
                </div>
              </div>
              <form class="questions" id="step-form">
                <fieldset>
                  <legend>Questo video &egrave; generato dall\'IA?</legend>
                  <label class="option">
                    <input type="radio" name="is-ai" value="yes" ${isAi === 'yes' ? 'checked' : ''}>
                    S&igrave;
                  </label>
                  <label class="option">
                    <input type="radio" name="is-ai" value="no" ${isAi === 'no' ? 'checked' : ''}>
                    No
                  </label>
                </fieldset>
                <fieldset class="stars-fieldset">
                  <legend>Valuta la qualit&agrave;</legend>
                  <div class="stars" role="radiogroup" aria-label="Valutazione della qualit&agrave; da una a cinque stelle">
                    ${[1, 2, 3, 4, 5].map((value) => `
                      <div class="star-wrapper">
                        <input type="radio" id="quality-${value}" name="quality" value="${value}" ${quality === value ? 'checked' : ''}>
                        <label for="quality-${value}" data-value="${value}" aria-label="${value} ${value === 1 ? 'stella' : 'stelle'}">★</label>
                      </div>
                    `).join('')}
                  </div>
                </fieldset>
              </form>
            </div>
            <div class="nav-buttons">
              <button type="button" class="secondary" data-action="back">Indietro</button>
              <button type="button" class="primary" data-action="next" disabled>Avanti</button>
            </div>
            <div class="status" data-role="status" aria-live="polite"></div>
          </section>
        `;
        setupVideoPlayback(videoUrl, videoMimeType);
        setupStepListeners(index, quality);
      }

      function setupVideoPlayback(videoUrl, videoMimeType) {
        const videoEl = appEl.querySelector('.video-area video');
        if (!videoEl) {
          return;
        }

        const videoAreaEl = appEl.querySelector('[data-role="video-area"]');
        if (videoAreaEl) {
          videoAreaEl.classList.remove('has-fallback');
        }

        const sourceEl = videoEl.querySelector('source');
        if (sourceEl) {
          sourceEl.src = videoUrl;
          sourceEl.type = videoMimeType;
        }

        videoEl.setAttribute('src', videoUrl);
        videoEl.src = videoUrl;
        videoEl.setAttribute('playsinline', '');
        videoEl.setAttribute('webkit-playsinline', '');

        const fallbackEl = appEl.querySelector('[data-role="video-fallback"]');
        const fallbackPlayerEl = fallbackEl ? fallbackEl.querySelector('[data-role="video-fallback-player"]') : null;
        if (fallbackEl) {
          fallbackEl.hidden = true;
          const fallbackLink = fallbackEl.querySelector('a');
          if (fallbackLink) {
            fallbackLink.href = videoUrl;
          }
        }
        if (fallbackPlayerEl) {
          fallbackPlayerEl.hidden = true;
          fallbackPlayerEl.innerHTML = '';
        }

        const fallbackStatusMessage = 'Abbiamo attivato un lettore alternativo per questo video. Se non funziona, usa il link di supporto.';
        let fallbackVisible = false;

        function hideFallback() {
          if (fallbackEl) {
            fallbackEl.hidden = true;
          }
          if (fallbackVisible && state.statusMessage === fallbackStatusMessage) {
            setStatus('', 'info');
          }
          if (fallbackPlayerEl) {
            fallbackPlayerEl.hidden = true;
            fallbackPlayerEl.innerHTML = '';
          }
          if (videoAreaEl) {
            videoAreaEl.classList.remove('has-fallback');
          }
          fallbackVisible = false;
        }

        function showFallback() {
          if (fallbackVisible) {
            return;
          }
          fallbackVisible = true;
          if (fallbackEl) {
            fallbackEl.hidden = false;
          }
          if (videoAreaEl) {
            videoAreaEl.classList.add('has-fallback');
          }
          if (fallbackPlayerEl) {
            fallbackPlayerEl.innerHTML = '';
            const iframe = document.createElement('iframe');
            iframe.setAttribute('title', 'Riproduzione alternativa del video');
            iframe.setAttribute('loading', 'lazy');
            iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
            iframe.setAttribute('allowfullscreen', '');
            iframe.setAttribute('referrerpolicy', 'no-referrer');
            iframe.srcdoc = buildFallbackPlayerHtml(videoUrl, videoMimeType);
            fallbackPlayerEl.appendChild(iframe);
            fallbackPlayerEl.hidden = false;
          }
          if (typeof videoEl.pause === 'function') {
            try {
              videoEl.pause();
            } catch (err) {
              // Ignoriamo gli errori derivanti dalla pausa del video non caricato.
            }
          }
          setStatus(fallbackStatusMessage, 'error');
        }

        videoEl.addEventListener('error', showFallback);
        videoEl.addEventListener('loadeddata', hideFallback);
        videoEl.addEventListener('loadedmetadata', hideFallback);
        videoEl.addEventListener('canplay', hideFallback);
        videoEl.addEventListener('play', hideFallback);

        if (typeof videoEl.load === 'function') {
          try {
            videoEl.load();
          } catch (err) {
            // Ignoriamo gli errori del caricamento programmatico.
          }
        }

        if (videoEl.readyState >= 2) {
          hideFallback();
        } else if (videoEl.error) {
          showFallback();
        }
      }

      function setupStepListeners(index, quality) {
        const form = document.getElementById('step-form');
        const nextBtn = appEl.querySelector('[data-action="next"]');
        const backBtn = appEl.querySelector('[data-action="back"]');
        const starsContainer = form.querySelector('.stars');
        const qualityInputs = Array.from(form.querySelectorAll('input[name="quality"]'));
        const aiInputs = Array.from(form.querySelectorAll('input[name="is-ai"]'));

        paintStars(starsContainer, quality);

        function updateNextState() {
          const answer = state.answers[index] || {};
          const aiAnswered = answer.is_ai === 'yes' || answer.is_ai === 'no';
          const qualityAnswered = typeof answer.quality === 'number' && answer.quality >= 1 && answer.quality <= 5;
          nextBtn.disabled = !(aiAnswered && qualityAnswered);
        }

        aiInputs.forEach((input) => {
          input.addEventListener('change', (event) => {
            saveAnswer(index, { is_ai: event.target.value });
            updateNextState();
          });
          input.addEventListener('keydown', handleRadioNavigation);
        });

        qualityInputs.forEach((input) => {
          input.addEventListener('change', (event) => {
            const value = Number(event.target.value);
            paintStars(starsContainer, value);
            saveAnswer(index, { quality: value });
            updateNextState();
          });
          input.addEventListener('keydown', (event) => handleStarKeydown(event, qualityInputs));
        });

        starsContainer.addEventListener('keydown', (event) => handleStarKeydown(event, qualityInputs));

        backBtn.addEventListener('click', () => {
          if (index === 0) {
            state.started = false;
            persistState();
            render();
            return;
          }
          state.currentIndex = Math.max(0, index - 1);
          persistState();
          render();
        });

        nextBtn.addEventListener('click', async () => {
          const answer = state.answers[index] || {};
          if (!isAnswerComplete(answer)) {
            setStatus('Rispondi a entrambe le domande prima di continuare.', 'error');
            updateNextState();
            return;
          }
          nextBtn.disabled = true;
          nextBtn.textContent = 'Salvataggio in corso…';
          const record = buildRecord(index, answer);
          const result = await postRecord(record);
          if (!result.ok) {
            setStatus('La tua risposta &egrave; salvata in locale e verr&agrave; sincronizzata appena possibile.', 'warning');
          }
          state.currentIndex = index + 1;
          state.started = true;
          persistState();
          render();
          flushQueue();
        });

        updateNextState();
      }

      function isAnswerComplete(answer) {
        if (!answer) {
          return false;
        }
        const aiAnswered = answer.is_ai === 'yes' || answer.is_ai === 'no';
        const qualityAnswered = typeof answer.quality === 'number' && answer.quality >= 1 && answer.quality <= 5;
        return aiAnswered && qualityAnswered;
      }

      function renderFinal() {
        const total = state.config.videos.length;
        const pending = state.queueLength;
        const allSent = allAnswersPosted();
        const readyToSubmit = pending === 0 && allSent;
        const noteText = state.submitted
          ? ''
          : readyToSubmit
            ? 'Premi "Invia" per completare.'
            : 'Mantieni questa pagina aperta finch&eacute; tutte le risposte non sono state sincronizzate.';
        appEl.innerHTML = `
          <section class="card final-view" aria-labelledby="final-title">
            <div class="logo">
              <img src="MFE_-_MediaForEurope_Logo%20(1).png" alt="Logo MediaForEurope">
            </div>
            <h1 id="final-title">${escapeHtml(state.config.SURVEY_TITLE)}</h1>
            <p class="final-message">Ottimo lavoro! Hai esaminato tutti i ${total} video.</p>
            ${noteText ? `<p class="final-note">${noteText}</p>` : ''}
            <div class="final-actions">
              <button type="button" class="primary" id="submit-btn" ${readyToSubmit && !state.submitted ? '' : 'disabled'}>${state.submitted ? 'Inviato' : 'Invia'}</button>
            </div>
            <div class="status" data-role="status" aria-live="polite"></div>
            ${state.submitted ? '<p class="final-success">Fatto! Le risposte sono state salvate e puoi chiudere questa pagina. Grazie!</p>' : ''}
          </section>
        `;

        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
          submitBtn.addEventListener('click', async () => {
            if (state.submitted) {
              return;
            }
            if (state.queueLength > 0 || !allAnswersPosted()) {
              setStatus('Stiamo ancora sincronizzando le tue risposte. Attendi che la coda sia vuota.', 'warning');
              renderFinal();
              return;
            }
            submitBtn.disabled = true;
            submitBtn.textContent = 'Invio in corso…';
            const success = await flushQueue();
            if (success && allAnswersPosted()) {
              state.submitted = true;
              persistState();
              setStatus('', 'info');
            } else {
              submitBtn.disabled = false;
              submitBtn.textContent = 'Invia';
              setStatus('Non &egrave; stato possibile confermare l\'invio. Controlla la connessione e riprova.', 'error');
            }
            renderFinal();
          });
        }
      }

      function saveAnswer(index, partial) {
        const current = state.answers[index] ? { ...state.answers[index] } : {};
        let changed = false;
        if (Object.prototype.hasOwnProperty.call(partial, 'is_ai')) {
          if (current.is_ai !== partial.is_ai) {
            changed = true;
          }
          current.is_ai = partial.is_ai;
        }
        if (Object.prototype.hasOwnProperty.call(partial, 'quality')) {
          if (current.quality !== partial.quality) {
            changed = true;
          }
          current.quality = partial.quality;
        }
        if (changed) {
          if (current.submissionId && dataAdapter) {
            dataAdapter.discard(current.submissionId);
          }
          delete current.submissionId;
          current.posted = false;
        }
        state.answers[index] = current;
        persistState();
      }

      function buildRecord(index, answer) {
        const videoId = makeVideoId(index);
        const submissionId = makeSubmissionId(state.uid, videoId, answer);
        const timestamp = new Date().toISOString();
        const record = {
          user_code: state.uid,
          video_id: videoId,
          is_ai: answer.is_ai,
          quality_rating: answer.quality,
          timestamp,
          user_agent: navigator.userAgent,
          submission_id: submissionId
        };
        answer.submissionId = submissionId;
        answer.posted = false;
        state.answers[index] = answer;
        persistState();
        return record;
      }

      function postRecord(record) {
        if (!dataAdapter) {
          return Promise.resolve({ ok: false, error: 'Adattatore dati non disponibile.' });
        }
        return dataAdapter.postRecord(record).then((response) => {
          if (response.ok) {
            setStatus('', 'info');
          }
          return response;
        });
      }

      function flushQueue() {
        if (!dataAdapter) {
          return Promise.resolve(false);
        }
        return dataAdapter.flushQueue().then((allSent) => {
          if (allSent && state.queueLength === 0 && allAnswersPosted()) {
            setStatus('Tutte le risposte sono sincronizzate.', 'success');
          }
          return allSent;
        });
      }

      function handleQueueChange(queue) {
        state.queueLength = queue.length;
        if (getRoute() === 'final') {
          renderFinal();
        }
        renderDebugPanel();
      }

      function markRecordSent(submissionId) {
        if (!submissionId) {
          return;
        }
        let updated = false;
        state.answers = state.answers.map((answer) => {
          if (answer && answer.submissionId === submissionId) {
            updated = true;
            return { ...answer, posted: true };
          }
          return answer;
        });
        if (updated) {
          persistState();
          if (state.queueLength === 0 && allAnswersPosted()) {
            setStatus('Tutte le risposte sono sincronizzate.', 'success');
          }
        }
      }

      function allAnswersPosted() {
        const total = state.config.videos.length;
        for (let i = 0; i < total; i += 1) {
          const answer = state.answers[i];
          if (!answer || !answer.posted) {
            return false;
          }
        }
        return true;
      }

      function renderStatus() {
        const statusEl = document.querySelector('[data-role="status"]');
        if (!statusEl) {
          return;
        }
        if (!state.statusMessage) {
          statusEl.textContent = '';
          statusEl.classList.add('hidden');
        } else {
          statusEl.textContent = state.statusMessage;
          statusEl.classList.remove('hidden');
        }
        statusEl.setAttribute('data-type', state.statusType || 'info');
      }

      function setStatus(message, type) {
        state.statusMessage = message || '';
        state.statusType = type || 'info';
        renderStatus();
      }

      function renderDebugPanel() {
        const existing = document.getElementById('debug-panel');
        if (!state.debug) {
          if (existing) {
            existing.remove();
          }
          return;
        }
        let panel = existing;
        if (!panel) {
          panel = document.createElement('aside');
          panel.id = 'debug-panel';
          panel.className = 'debug-panel';
          document.body.appendChild(panel);
        }
        const total = state.config ? state.config.videos.length : 0;
        panel.innerHTML = `
          <h3>Informazioni di debug</h3>
          <p><strong>ID sessione:</strong> ${escapeHtml(state.uid || 'n/d')}</p>
          <p><strong>Indice:</strong> ${state.currentIndex}/${total}</p>
          <p><strong>Coda:</strong> ${state.queueLength}</p>
          <button type="button" id="clear-debug">Cancella dati locali</button>
        `;
        const clearBtn = document.getElementById('clear-debug');
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            if (!state.uid) {
              return;
            }
            const storage = getStateStorage();
            if (storage) {
              storage.removeItem(storageKeys.state(state.uid));
            }
            localStorage.removeItem(storageKeys.queue(state.uid));
            window.location.reload();
          });
        }
      }

      function makeVideoId(index) {
        const number = String(index + 1).padStart(2, '0');
        return `video-${number}`;
      }

      function makeSubmissionId(uid, videoId, answer) {
        const payload = `${uid}::${videoId}::${answer.is_ai}::${answer.quality}`;
        const hash = hashString(payload);
        return `${uid}-${videoId}-${hash}`;
      }

      function hashString(value) {
        let hash = 0;
        for (let i = 0; i < value.length; i += 1) {
          hash = (hash << 5) - hash + value.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash).toString(16);
      }

      function normalizeVideos(videos, baseUrl) {
        return videos.map((entry, index) => {
          const resolved = resolveVideoEntry(entry, baseUrl);
          if (!isNonEmptyString(resolved)) {
            throw new Error(`Voce video non valida in posizione ${index + 1}.`);
          }
          return resolved;
        });
      }

      function buildFallbackPlayerHtml(videoUrl, videoMimeType) {
        if (!isNonEmptyString(videoUrl)) {
          return `<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #04070d;
      color: #eef3ff;
      font-family: 'Geologica', 'Inter', 'Segoe UI', system-ui, sans-serif;
      padding: 1.5rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <p>Non è stato possibile preparare il lettore alternativo. Riprova a caricare la pagina o apri il video manualmente.</p>
</body>
</html>`;
        }
        const safeUrl = escapeAttribute(videoUrl);
        const safeType = escapeAttribute(videoMimeType || getVideoMimeType(videoUrl));
        return `<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #04070d;
      color: #eef3ff;
      font-family: 'Geologica', 'Inter', 'Segoe UI', system-ui, sans-serif;
      padding: 1rem;
    }
    main {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    video {
      width: 100%;
      height: auto;
      border: none;
      border-radius: 12px;
      background: #000;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
    }
    p {
      margin: 0;
      font-size: 0.9375rem;
      line-height: 1.45;
      color: rgba(220, 232, 255, 0.8);
      text-align: center;
    }
    a {
      color: #6cb5ff;
    }
  </style>
</head>
<body>
  <main>
    <video controls playsinline preload="metadata" controlsList="nodownload">
      <source src="${safeUrl}" type="${safeType}">
      Il tuo browser non supporta il video. <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">Scarica il file</a>.
    </video>
    <p>Se il lettore non parte, usa il link sopra per aprire o scaricare il video.</p>
  </main>
</body>
</html>`;
      }

      function resolveVideoEntry(entry, baseUrl) {
        if (typeof entry === 'string') {
          return resolveVideoUrl(entry, baseUrl);
        }
        if (entry && typeof entry === 'object') {
          const candidates = [entry.url, entry.href, entry.path, entry.key, entry.filename, entry.file];
          const candidate = candidates.find((value) => isNonEmptyString(value));
          const candidateBase = isNonEmptyString(entry.baseUrl) ? entry.baseUrl : baseUrl;
          if (isNonEmptyString(candidate)) {
            return resolveVideoUrl(candidate, candidateBase);
          }
        }
        return '';
      }

      function resolveVideoUrl(value, baseUrl) {
        const trimmed = String(value || '').trim();
        if (!trimmed) {
          return '';
        }
        if (trimmed.startsWith('//')) {
          return `${window.location.protocol}${trimmed}`;
        }
        if (isAbsoluteUrl(trimmed) || trimmed.startsWith('data:')) {
          return trimmed;
        }
        const base = isNonEmptyString(baseUrl) ? baseUrl.trim() : '';
        if (!base) {
          return trimmed;
        }
        return joinUrl(base, trimmed);
      }

      function isAbsoluteUrl(value) {
        return /^https?:\/\//i.test(value);
      }

      function joinUrl(base, path) {
        const baseStr = String(base || '').trim();
        const pathStr = String(path || '').trim();
        if (!baseStr) {
          return pathStr;
        }
        if (!pathStr) {
          return baseStr;
        }
        const baseHasSlash = baseStr.endsWith('/');
        const pathHasSlash = pathStr.startsWith('/');
        if (baseHasSlash && pathHasSlash) {
          return baseStr + pathStr.slice(1);
        }
        if (!baseHasSlash && !pathHasSlash) {
          return `${baseStr}/${pathStr}`;
        }
        return baseStr + pathStr;
      }

      function isNonEmptyString(value) {
        return typeof value === 'string' && value.trim().length > 0;
      }

      function escapeHtml(str) {
        if (typeof str !== 'string') {
          return '';
        }
        return str.replace(/[&<>"']/g, (char) => {
          switch (char) {
            case '&':
              return '&amp;';
            case '<':
              return '&lt;';
            case '>':
              return '&gt;';
            case '"':
              return '&quot;';
            case '\'':
              return '&#39;';
            default:
              return char;
          }
        });
      }

      function escapeAttribute(value) {
        return escapeHtml(String(value));
      }

      function getVideoMimeType(url) {
        if (!isNonEmptyString(url)) {
          return 'video/mp4';
        }
        const cleaned = String(url).split(/[?#]/)[0].trim().toLowerCase();
        if (cleaned.endsWith('.m3u8')) {
          return 'application/x-mpegURL';
        }
        if (cleaned.endsWith('.mpd')) {
          return 'application/dash+xml';
        }
        if (cleaned.endsWith('.webm')) {
          return 'video/webm';
        }
        if (cleaned.endsWith('.ogv') || cleaned.endsWith('.ogg')) {
          return 'video/ogg';
        }
        if (cleaned.endsWith('.mov') || cleaned.endsWith('.qt')) {
          return 'video/quicktime';
        }
        if (cleaned.endsWith('.m4v')) {
          return 'video/x-m4v';
        }
        return 'video/mp4';
      }

      function paintStars(container, value) {
        if (!container) {
          return;
        }
        const labels = Array.from(container.querySelectorAll('label'));
        labels.forEach((label) => {
          const starValue = Number(label.dataset.value);
          if (value && starValue <= value) {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
        });
      }

      function handleStarKeydown(event, inputs) {
        if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
          return;
        }
        event.preventDefault();
        const step = event.key === 'ArrowLeft' || event.key === 'ArrowDown' ? -1 : 1;
        const list = Array.from(inputs);
        let index = list.findIndex((input) => input === document.activeElement);
        if (index === -1) {
          index = list.findIndex((input) => input.checked);
        }
        if (index === -1) {
          index = 0;
        }
        let targetIndex = index + step;
        targetIndex = Math.min(Math.max(targetIndex, 0), list.length - 1);
        const target = list[targetIndex];
        if (target) {
          target.checked = true;
          target.focus();
          target.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }

      function handleRadioNavigation(event) {
        if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
          return;
        }
        const radios = Array.from(document.querySelectorAll('input[name="is-ai"]'));
        const currentIndex = radios.findIndex((radio) => radio === event.target);
        if (currentIndex === -1) {
          return;
        }
        event.preventDefault();
        const step = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;
        let nextIndex = currentIndex + step;
        if (nextIndex < 0) {
          nextIndex = radios.length - 1;
        } else if (nextIndex >= radios.length) {
          nextIndex = 0;
        }
        const target = radios[nextIndex];
        if (target) {
          target.checked = true;
          target.focus();
          target.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }

      function createDataAdapter(uid) {
        const queueKey = storageKeys.queue(uid);
        let queue = [];
        const queueListeners = [];
        let onSent = () => {};
        let onError = () => {};

        loadQueue();

        function loadQueue() {
          const raw = localStorage.getItem(queueKey);
          if (!raw) {
            queue = [];
            return;
          }
          try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              queue = parsed;
            } else {
              queue = [];
            }
          } catch (err) {
            queue = [];
          }
        }

        function persistQueue() {
          try {
            localStorage.setItem(queueKey, JSON.stringify(queue));
          } catch (err) {
            console.warn('Impossibile salvare la coda', err);
          }
          notifyQueueChange();
        }

        function notifyQueueChange() {
          const snapshot = queue.slice();
          queueListeners.forEach((listener) => listener(snapshot));
        }

        async function send(record) {
          const response = await fetch(CONFIG.FORM_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Accept: 'application/json'
            },
            body: JSON.stringify(record),
            keepalive: true
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          let payload = {};
          const text = await response.text();
          if (text) {
            try {
              payload = JSON.parse(text);
            } catch (err) {
              console.warn('Impossibile analizzare la risposta del server come JSON', err);
              payload = {};
            }
          }
          if (payload && (payload.ok === false || payload.error)) {
            throw new Error(payload.error || 'Errore del server');
          }
          return payload;
        }

        function enqueue(record) {
          queue.push(record);
          persistQueue();
        }

        return {
          postRecord: async (record) => {
            if (!CONFIG || !CONFIG.FORM_ENDPOINT) {
              onError('Il server per le risposte non è configurato. Riprova più tardi.');
              enqueue(record);
              return { ok: false, error: 'Endpoint del modulo mancante' };
            }
            try {
              const response = await send(record);
              onSent(record, response);
              return { ok: true, response };
            } catch (err) {
              enqueue(record);
              onError('Impossibile raggiungere il server delle risposte. Le risposte verranno sincronizzate automaticamente quando la connessione verrà ripristinata.');
              return { ok: false, error: err instanceof Error ? err.message : String(err) };
            }
          },
          flushQueue: async () => {
            if (!CONFIG || !CONFIG.FORM_ENDPOINT) {
              onError('Il server per le risposte non è configurato. Riprova più tardi.');
              return false;
            }
            if (queue.length === 0) {
              notifyQueueChange();
              return true;
            }
            const remaining = [];
            let allSent = true;
            for (const record of queue) {
              try {
                const payload = await send(record);
                onSent(record, payload);
              } catch (err) {
                remaining.push(record);
                allSent = false;
              }
            }
            queue = remaining;
            persistQueue();
            if (!allSent) {
              onError('Alcune risposte sono ancora in sospeso. Il tentativo verrà ripetuto automaticamente.');
            }
            return allSent;
          },
          getQueue: () => queue.slice(),
          onQueueChange: (listener) => {
            queueListeners.push(listener);
            listener(queue.slice());
          },
          setOnSent: (listener) => {
            onSent = listener;
          },
          setOnError: (listener) => {
            onError = listener;
          },
          discard: (submissionId) => {
            if (!submissionId) {
              return;
            }
            const initialLength = queue.length;
            queue = queue.filter((item) => item.submission_id !== submissionId);
            if (queue.length !== initialLength) {
              persistQueue();
            }
          },
          flushQueueWithBeacon: () => {
            if (!CONFIG || !CONFIG.FORM_ENDPOINT || typeof navigator.sendBeacon !== 'function') {
              return;
            }
            queue.forEach((record) => {
              try {
                const blob = new Blob([JSON.stringify(record)], { type: 'application/json' });
                navigator.sendBeacon(CONFIG.FORM_ENDPOINT, blob);
              } catch (err) {
                /* ignore beacon failures */
              }
            });
          }
        };
      }
    })();
  </script>
</body>
</html>
